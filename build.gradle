project.ext.useCommandLine = project.hasProperty('haleCliExecutable')

project.ext.advAlignmentsPath = project.hasProperty('advAlignments') ? project.getProperty('advAlignments') : 'adv-alignments'

def cliVersion = '3.1.0-SNAPSHOT'

if (!project.ext.useCommandLine) {
  configurations {
    hale
  }

  repositories {
    mavenLocal() // XXX for testing

    maven { // wetransform release repository (HALE releases and Eclipse dependencies)
      url 'https://artifactory.wetransform.to/artifactory/libs-release-local'
    }
    maven { // wetransform snapshot repository (HALE snapshots)
      url 'https://artifactory.wetransform.to/artifactory/libs-snapshot-local'
    }
    
    // these need to be before jcenter/MavenCentral for retrieving JAI
    maven {
      url 'http://download.java.net/maven/2'
    }
    maven {
      url 'http://download.osgeo.org/webdav/geotools/'
    }
    
    maven { // HALE artifactory (dependencies for HALE)
      url 'http://artifactory.esdi-humboldt.eu/artifactory/libs-release/'
    }
    
    maven {
      url 'http://repo.opengeo.org'
    }
    jcenter()
  }

  configurations.all {
    // resolutionStrategy.cacheChangingModulesFor 60, 'minutes'
    resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
  }

  dependencies {
    // hale CLI
    // hale "to.wetransform:hale-cli:$cliVersion"
    hale "to.wetransform:hale-cli-rlp:$cliVersion"
  }
}

task('dbMatching', type: HaleCommandLine) {
  args = [
    'rlp',
    'match-schemas',
    '--reference-schema',
    advAlignmentsPath + '/schemas/NAS_6.0.1/schema/aaa.xsd',
    '--target-schema',
    'database/schema.hsd',
    '--target',
    'database/matching.halex'
  ]

  description "Generate matching project between AAA XSD and RLP PostNAS schemas"
  group 'Alignment migration'
}


def json = new groovy.json.JsonSlurper()
def migrations = json.parse(file(project.hasProperty('migrationsFile') ? project.getProperty('migrationsFile') : 'migrations.json'))

/*
task('migrate-all') {
  description "Runs all migration tasks (for all configured projects)."
  group 'Alignment migration'
}
*/

migrations.each { name, config ->
  if (config.enabled != null && !config.enabled) {
    return
  }

  def projectsDir = file('projects')
  if (!projectsDir.exists()) projectsDir.mkdirs()
  def autoProjectFile = new File(projectsDir, "${name}-auto.halex")
  def manualProjectFile = new File(projectsDir, "${name}-manual.halex")
  def dbProjectFile = new File(projectsDir, "${name}-db.halex")

  def diffFile = new File(projectsDir, "${name}-manual.diff")

  // create diff to previously created manual project
  task("diff-$name").doLast {
    if (manualProjectFile.exists()) {
      exec {
        commandLine'git', 'diff', '-p', '--no-index',
          projectDir.toPath().relativize(autoProjectFile.toPath()).toString() + '.alignment.xml',
          projectDir.toPath().relativize(manualProjectFile.toPath()).toString() + '.alignment.xml'

        // git seems to always return with an exit code here
        ignoreExitValue = true

        standardOutput = diffFile.newOutputStream()
        // errorOutput = new TeeOutputStream(errFile.newOutputStream(), errorOutput)
      }

      if (!diffFile.length()) {
        diffFile.delete()
      }
    }

    description "Create a diff between the manually curated and the automatically generated migration project (${name})"
    group 'Alignment migration'
  }

  // add migration task for each project
  task("auto-$name", type: HaleCommandLine, dependsOn: "diff-$name") {
    args = [
      'project',
      'migrate',
      'matching',
      '--source-project',
      advAlignmentsPath + '/' + config.advProject,
      '--matching-project',
      'database/matching.halex', // PostNAS
      '--target',
      autoProjectFile as String
    ]

    description "Automatical migration of AdV project ${config.advProject} to PostNAS schema"
    group 'Alignment migration'
  }

  task("migrate-$name", dependsOn: "auto-$name") {
    description "Migrate AdV project ${config.advProject} to PostNAS schema, attempts to update manually curated project"
    group 'Alignment migration'
  }.doLast {
    // copy project
    copy {
      from projectsDir
      include projectsDir.toPath().relativize(autoProjectFile.toPath()).toString()
      include projectsDir.toPath().relativize(autoProjectFile.toPath()).toString() + '.alignment.xml'
      into projectsDir

      rename(/(.*)-auto(.*)/, '$1-manual$2')
    }
    // adapt project file to reference correct alignment
    manualProjectFile.text = manualProjectFile.text.replaceFirst(
      /-auto\.halex\.alignment\.xml/,
      '-manual.halex.alignment.xml')
    manualProjectFile.text = manualProjectFile.text.replaceFirst(
      /-auto\.halex/,
      '-manual.halex')

    if (diffFile.exists() && diffFile.length()) {
      // apply diff
      
      // first create a copy of the generated alignment (as git deletes the file)
      def tempFile = new File(getTemporaryDir(), autoProjectFile.name)
      copy {
        from autoProjectFile.toString() + '.alignment.xml'
        into tempFile.parentFile
        rename {
          tempFile.name
        }
      }
      // apply diff with git
      def error
      try {
        // try at least a partial apply
        // see also http://stackoverflow.com/questions/15796528/partial-git-apply
        exec {
          commandLine 'git', 'apply', '--reject', '--verbose', projectDir.toPath().relativize(diffFile.toPath()).toString()
        }
      } catch (e) {
        error = e
      }
      // recreate generated alignment file
      copy {
        from tempFile
        into projectsDir
        rename {
          autoProjectFile.name + '.alignment.xml'
        }
      }

      // handle git apply problem
      if (error) {
        println "ERROR applying diff to update manually curated project."
        println "Please check if you can apply the changes manually."
        println "Please check any .rej files for rejected hunks."
        println "Be aware that the manually created project has been replaced by the generated version."
      }
    }
  }

  // tasks['migrate-all'].dependsOn("migrate-$name")

  // change source to database
  task("db-migrate-$name", type: HaleCommandLine) {
    args = [
      'project', 'migrate', 'source',
      '--schema',
      project.hasProperty('db.uri') ? project.getProperty('db.uri') : 'jdbc:postgresql://localhost:5432/testbed',
      '--schema-reader', 'eu.esdihumboldt.hale.io.jdbc.schema.reader',
      '--schema-setting',
      'jdbc.user=' + (project.hasProperty('db.user') ? project.getProperty('db.user') : 'postgres'),
      '--schema-setting',
      'jdbc.password=' + (project.hasProperty('db.password') ? project.getProperty('db.password') : 'postgres'),
      '--source-project',
      manualProjectFile as String,
      '--target',
      dbProjectFile as String
    ]

    def schemas = project.hasProperty('db.schemas') ? project.getProperty('db.schemas') : null
    if (schemas) {
      args << '--schema-setting'
      args << "schemas=$schemas"
    }

    description "Adapt the manually curated ${name}-project to a custom database connection"
    group 'Alignment migration'
  }

}

// task and helper classes

/**
 * Generic CLI task.
 */
class HaleCommandLine extends DefaultTask {

  /**
   * CLI arguments.
   */
  List<String> args = []

  /**
   * Maximum heap size in megabytes.
   */
  int maxHeapSizeMB = project.hasProperty('haleMaxHeapSize') ? (project.getProperty('haleMaxHeapSize') as int) : 2048

  /**
   * States if the hale CLI tool (or library) is required, i.e
   * halestudio cannot be used.
   */
  boolean requiresHaleCli = false

  /**
   * Map of project variables.
   */
  Map<String, String> projectVariables = [:]

  @TaskAction
  void runCommand() {
    // build command line
    def cmd

    boolean usingHaleCli = false
    boolean useCommandLine = true

    // executable
    if (project.hasProperty('haleCliExecutable')) {
      println 'Using hale CLI executable at ' + project.getProperty('haleCliExecutable')
      cmd = [project.getProperty('haleCliExecutable')]
      cmd.addAll(args)
      usingHaleCli = true
    }
    else {
      // using libraries on classpath
      println 'Using libraries on classpath...'
      cmd = args
      usingHaleCli = false
      useCommandLine = false
    }

    if (useCommandLine) {
      // execution via external command

      project.exec {
        commandLine = cmd

        // environment
        
        // HALE_OPTS if using hale-cli
        if (usingHaleCli) {
          List<String> haleOpts = []
          
          // max heap size
          haleOpts << "-Xmx${maxHeapSizeMB}m"

          // proxy configuration
          Helpers.addProxyArgs(haleOpts)
          // additional system properties
          Helpers.addSystemProps(project, haleOpts)

          if (haleOpts) {
            environment('HALE_OPTS', haleOpts.join(' '))
          }
        }
      }
    }
    else {
      // execution via libraries in classpath

      project.javaexec {
        classpath project.configurations.hale
        main = "to.wetransform.halecli.CLI"
        args = cmd
        def vmargs = ['-Dcache.level1.enabled=false', '-Dcache.level1.size=0',
          '-Dcache.level2.enabled=false', '-Dcache.level2.size=0']

        // proxy configuration
        Helpers.addProxyArgs(vmargs)
        // additional system properties
        Helpers.addSystemProps(project, vmargs)

        // max heap size
        maxHeapSize = "${maxHeapSizeMB}m"
        
        jvmArgs = vmargs
      }
    }

  }

}

class Helpers {
  /**
   * List of proxy related system properties.
   */
  static final PROXY_PROPS = [
    'http.proxyHost',
    'http.proxyPort',
    'http.proxyUser',
    'http.proxyPassword',
    'http.nonProxyHosts',
    'https.proxyHost',
    'https.proxyPort',
    'https.proxyUser',
    'https.proxyPassword',
    'https.nonProxyHosts'
  ].asImmutable()

  /**
   * Helper to add HTTP-Proxy system property arguments to an argument list.
   * 
   * @param argList The argument list to add the HTTP-Proxy configuration
   *   arguments to
   */
  static void addProxyArgs(List<String> argList) {
    PROXY_PROPS.each { name ->
      String prop = System.getProperty(name)
      if (prop != null) {
        argList << "-D${name}=${prop}"
      }
    }
  }

  /**
   * Add additionally defined system properties to the arguments.
   * 
   * @param argList The argument list to add the system properties to
   */
  static void addSystemProps(Project project, List<String> argList) {
    def propsFile = project.file('gradle.properties')
    if (!propsFile.exists()) {
      return
    }
    try {
      def props = new Properties()
      propsFile.withInputStream {
        props.load(it)
      }

      props.stringPropertyNames().each { name ->
        if (name.startsWith('systemProp.')) {
          def value = props.getProperty(name)
          if (value) {
            def strippedName = name[11..-1]
            if (!PROXY_PROPS.contains(strippedName)) {
              // don't handle proxy properties two times

              println "Adding system property ${strippedName} to command"
              argList << "-D${strippedName}=${value}"
            }
          }
        }
      }
    } catch (e) {
      println 'ERROR loading gradle.properties to extract system properties'
      e.printStackTrace()
    }
  }
}

class TeeOutputStream extends OutputStream {

  private final OutputStream out
  private final OutputStream tee

  TeeOutputStream(OutputStream out, OutputStream tee) {
    if (out == null)
      throw new NullPointerException()
    else if (tee == null)
      throw new NullPointerException()

    this.out = out
    this.tee = tee
  }

  @Override
  void write(int b) throws IOException {
    out.write(b);
    tee.write(b);
  }

  @Override
  void write(byte[] b) throws IOException {
    out.write(b);
    tee.write(b);
  }

  @Override
  void write(byte[] b, int off, int len) throws IOException {
    out.write(b, off, len);
    tee.write(b, off, len);
  }

  @Override
  void flush() throws IOException {
    out.flush();
    tee.flush();
  }

  @Override
  void close() throws IOException {
    out.close();
    tee.close();
  }
}

/*
 * Gradle wrapper
 */
task wrapper(type: Wrapper) {
  gradleVersion = '3.2'
}
