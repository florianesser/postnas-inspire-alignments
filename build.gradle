buildscript {
  repositories {
    maven {
      url 'https://artifactory.wetransform.to/artifactory/libs-release-local'
    }
  }
  dependencies {
    classpath 'to.wetransform.hale:gradle-hale-plugin:1.1.3'
  }
}

apply plugin: 'to.wetransform.hale'

hale {
  cliArtifact = 'to.wetransform:hale-cli'
  cliVersion = '3.4.0'
}

repositories {
  // mavenLocal() // XXX for testing
}

configurations.all {
  resolutionStrategy.cacheChangingModulesFor 180, 'minutes'
  //resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
}

project.ext.advAlignmentsPath = project.hasProperty('advAlignments') ? project.getProperty('advAlignments') : 'adv-alignments'

task('dbMatching', type: hale.cli()) {
  args = [
    'rlp',
    'match-schemas',
    '--reference-schema',
    advAlignmentsPath + '/schemas/NAS_6.0.1/schema/aaa.xsd',
    '--target-schema',
    'database/schema.hsd',
    '--target',
    'database/matching.halex'
  ]

  description "Generate matching project between AAA XSD and RLP PostNAS schemas"
  group 'Alignment migration'
}


def migrations = Config.load(file(project.hasProperty('migrationsFile') ? project.getProperty('migrationsFile') : 'migrations.yaml'))
def projectFiles = [:]

/*
task('migrate-all') {
  description "Runs all migration tasks (for all configured projects)."
  group 'Alignment migration'
}
*/

migrations.each { name, config ->
  if (config.enabled != null && !config.enabled) {
    return
  }

  def projectsDir = file('projects')
  if (!projectsDir.exists()) projectsDir.mkdirs()
  def autoProjectFile = new File(projectsDir, "${name}-auto.halex")
  def manualProjectFile = new File(projectsDir, "${name}-manual.halex")
  def dbProjectFile = new File(projectsDir, "${name}-db.halex")

  projectFiles[name] = dbProjectFile

  def diffFile = new File(projectsDir, "${name}-manual.diff")

  // create diff to previously created manual project
  task("diff-$name").doLast {
    if (manualProjectFile.exists()) {
      exec {
        commandLine'git', 'diff', '-p', '--no-index',
          projectDir.toPath().relativize(autoProjectFile.toPath()).toString() + '.alignment.xml',
          projectDir.toPath().relativize(manualProjectFile.toPath()).toString() + '.alignment.xml'

        // git seems to always return with an exit code here
        ignoreExitValue = true

        standardOutput = diffFile.newOutputStream()
        // errorOutput = new TeeOutputStream(errFile.newOutputStream(), errorOutput)
      }

      if (!diffFile.length()) {
        diffFile.delete()
      }
    }

    description "Create a diff between the manually curated and the automatically generated migration project (${name})"
    group 'Alignment migration'
  }

  // add migration task for each project
  task("auto-$name", type: hale.cli(), dependsOn: "diff-$name") {
    args = [
      'project',
      'migrate',
      'matching',
      '--source-project',
      advAlignmentsPath + '/' + config.advProject,
      '--matching-project',
      'database/matching.halex', // PostNAS
      '--target',
      autoProjectFile as String
    ]

    description "Automatical migration of AdV project ${config.advProject} to PostNAS schema"
    group 'Alignment migration'
  }

  task("migrate-$name", dependsOn: "auto-$name") {
    description "Migrate AdV project ${config.advProject} to PostNAS schema, attempts to update manually curated project"
    group 'Alignment migration'
  }.doLast {
    // copy project
    copy {
      from projectsDir
      include projectsDir.toPath().relativize(autoProjectFile.toPath()).toString()
      include projectsDir.toPath().relativize(autoProjectFile.toPath()).toString() + '.alignment.xml'
      into projectsDir

      rename(/(.*)-auto(.*)/, '$1-manual$2')
    }
    // adapt project file to reference correct alignment
    def manualText = manualProjectFile.getText('UTF-8')
    manualText = manualText.replaceFirst(
      /-auto\.halex\.alignment\.xml/,
      '-manual.halex.alignment.xml')
    manualText = manualText.replaceFirst(
      /-auto\.halex/,
      '-manual.halex')
    manualProjectFile.write(manualText, 'UTF-8')

    if (diffFile.exists() && diffFile.length()) {
      // apply diff
      
      // first create a copy of the generated alignment (as git deletes the file)
      def tempFile = new File(getTemporaryDir(), autoProjectFile.name)
      copy {
        from autoProjectFile.toString() + '.alignment.xml'
        into tempFile.parentFile
        rename {
          tempFile.name
        }
      }
      // apply diff with git
      def error
      try {
        // try at least a partial apply
        // see also http://stackoverflow.com/questions/15796528/partial-git-apply
        exec {
          commandLine 'git', 'apply', '--reject', '--verbose', projectDir.toPath().relativize(diffFile.toPath()).toString()
        }
      } catch (e) {
        error = e
      }
      // recreate generated alignment file
      copy {
        from tempFile
        into projectsDir
        rename {
          autoProjectFile.name + '.alignment.xml'
        }
      }

      // handle git apply problem
      if (error) {
        println "ERROR applying diff to update manually curated project."
        println "Please check if you can apply the changes manually."
        println "Please check any .rej files for rejected hunks."
        println "Be aware that the manually created project has been replaced by the generated version."
      }
    }
  }

  // tasks['migrate-all'].dependsOn("migrate-$name")

  // change source to database
  task("db-migrate-$name", type: hale.cli()) {
    args = [
      'project', 'migrate', 'source',
      '--schema',
      project.hasProperty('db.uri') ? project.getProperty('db.uri') : 'jdbc:postgresql://localhost:5432/testbed',
      '--schema-reader', 'eu.esdihumboldt.hale.io.jdbc.schema.reader',
      '--schema-setting',
      'jdbc.user=' + (project.hasProperty('db.user') ? project.getProperty('db.user') : 'postgres'),
      '--schema-setting',
      'jdbc.password=' + (project.hasProperty('db.password') ? project.getProperty('db.password') : 'postgres'),
      '--source-project',
      manualProjectFile as String,
      '--target',
      dbProjectFile as String
    ]

    def schemas = project.hasProperty('db.schemas') ? project.getProperty('db.schemas') : null
    if (schemas) {
      args << '--schema-setting'
      args << "schemas=$schemas"
    }

    description "Adapt the manually curated ${name}-project to a custom database connection"
    group 'Alignment migration'
  }

}

/*
 * Transformation
 */

def transformationFiles = [file('transformations.yaml')]
transformationFiles.addAll(fileTree(dir: projectDir).matching {
  //TODO configurable?
  include('transformations-override.yaml')
} as List)

def transformations = Config.load(transformationFiles as File[])

transformations.tasks.each { name, config ->
  // apply defaults
  if (transformations.defaults) {
    config = Config.mergeConfigs([transformations.defaults, config])
  }

  // check if enabled
  if (config.enabled != null && !config.enabled) {
    return
  }

  // requires a project to be set
  if (!config.project) {
    return
  }
  def projectId = config.project
  def projectFile = projectFiles[projectId]

  def targetFolder = new File(file('transformation'), name)
  def targetFile = new File(targetFolder, 'result.gml')

  task("transform-${name}", type: hale.transform(), dependsOn: "db-migrate-$projectId") {
    // transformation project
    transformation = projectFile

    // database source
    source(project.findProperty('db.uri') ?: 'jdbc:postgresql://localhost:5432/testbed') {
      provider 'eu.esdihumboldt.hale.io.jdbc.instance.reader'

      setting 'jdbc.user', (project.findProperty('db.user') ?: 'postgres')
      setting 'jdbc.password', (project.findProperty('db.password') ?: 'postgres')
    }

    if (config.model) {
      // restrict to a specific model -> add generic filter
      filterArgs << '-filter'
      filterArgs << "CQL:advstandardmodell = '${config.model}'"

      if (config.additionalModels) {
        // add filters for additional models (also accepting those)
        config.additionalModels.each { modelName ->
          filterArgs << '-filter'
          filterArgs << "CQL:advstandardmodell = '${modelName}'"
        }
      }

      // add project variable
      projectVariables['ADV_MODELLART'] = config.model
    }

    // project variables from config
    if (config.variables) {
      projectVariables << config.variables
    }

    // transformation target
    target(targetFile) {
      provider 'eu.esdihumboldt.hale.io.wfs.fc.write-2.0' // WFS 2 FC
      setting 'xml.pretty', true
      setting 'crs.epsg.prefix', 'http://www.opengis.net/def/crs/EPSG/0/'
      setting 'skipFeatureCount', true

      // custom settings
      if (config.writerSettings) {
        settings << config.writerSettings
      }
    }
    
    // XML schema validation
    if (config.validation.xmlSchema) {
      validate('eu.esdihumboldt.hale.io.xml.validator')
    }
    
    // folder for output and reports
    logFolder = targetFolder

    // general options
    printStacktrace = true
    trustGroovy = true

    // activate hale internal validation of transformed instances
    if (config.validation.haleInternal) {
      environment['HALE_TRANSFORMATION_INTERNAL_VALIDATION'] = 'true'
    }
    
    //FIXME hale 3.4 required
    // statistics and ...
    additionalArgs << '-statisticsOut'
    File statsFile = new File(targetFolder, 'statistics.json')
    additionalArgs << statsFile.absolutePath
    // ... success evaluation
    // additionalArgs << '-successEvaluation'
    // additionalArgs << project.file('success.groovy')

    description "Runs a transformation based on project ${projectId} for model $model."
    group 'Transformation'
  }.doFirst {
    targetFolder.deleteDir()
    targetFolder.mkdirs()
  }
}

/*
 * Gradle wrapper
 */
task wrapper(type: Wrapper) {
  gradleVersion = '4.8'
}
