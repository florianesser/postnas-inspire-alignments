project.ext.useCommandLine = project.hasProperty('haleCliExecutable')

project.ext.advAlignmentsPath = project.hasProperty('advAlignments') ? project.getProperty('advAlignments') : 'adv-alignments'

def cliVersion = '3.1.0-SNAPSHOT'

if (!project.ext.useCommandLine) {
  configurations {
    hale
  }

  repositories {
    mavenLocal() // XXX for testing

    maven { // wetransform release repository (HALE releases and Eclipse dependencies)
      url 'https://artifactory.wetransform.to/artifactory/libs-release-local'
    }
    maven { // wetransform snapshot repository (HALE snapshots)
      url 'https://artifactory.wetransform.to/artifactory/libs-snapshot-local'
    }
    
    // these need to be before jcenter/MavenCentral for retrieving JAI
    maven {
      url 'http://download.java.net/maven/2'
    }
    maven {
      url 'http://download.osgeo.org/webdav/geotools/'
    }
    
    maven { // HALE artifactory (dependencies for HALE)
      url 'http://artifactory.esdi-humboldt.eu/artifactory/libs-release/'
    }
    
    maven {
      url 'http://repo.opengeo.org'
    }
    jcenter()
  }

  configurations.all {
    // resolutionStrategy.cacheChangingModulesFor 60, 'minutes'
    resolutionStrategy.cacheChangingModulesFor 0, 'seconds'
  }

  dependencies {
    // hale CLI
    // hale "to.wetransform:hale-cli:$cliVersion"
    hale "to.wetransform:hale-cli-rlp:$cliVersion"
  }
}

task('dbMatching', type: HaleCommandLine) {
  args = [
    'rlp',
    'match-schemas',
    '--reference-schema',
    advAlignmentsPath + '/schemas/NAS_6.0.1/schema/aaa.xsd',
    '--target-schema',
    'database/schema.hsd',
    '--target',
    'database/matching.halex'
  ]

  description "Generate matching project between AAA XSD and RLP PostNAS schemas"
  group 'Alignment migration'
}


def json = new groovy.json.JsonSlurper()
def migrations = json.parse(file(project.hasProperty('migrationsFile') ? project.getProperty('migrationsFile') : 'migrations.json'))

task('migrate-all') {
  description "Runs all migration tasks (for all configured projects)."
  group 'Alignment migration'
}

migrations.each { name, config ->
  if (config.enabled != null && !config.enabled) {
    return
  }

  def projectsDir = file('projects')
  if (!projectsDir.exists()) projectsDir.mkdirs()
  def autoProjectFile = new File(projectsDir, "${name}-auto.halex")

  // add migration task for each key
  task("migrate-$name", type: HaleCommandLine) {
    args = [
      'project',
      'migrate',
      'matching',
      '--source-project',
      advAlignmentsPath + '/' + config.advProject,
      '--matching-project',
      'database/matching.halex', // PostNAS
      '--target',
      autoProjectFile as String
    ]

    description "Migrate AdV project ${config.advProject} to PostNAS schema"
    group 'Alignment migration'
  }

  tasks['migrate-all'].dependsOn("migrate-$name")

}

// task and helper classes

/**
 * Generic CLI task.
 */
class HaleCommandLine extends DefaultTask {

  /**
   * CLI arguments.
   */
  List<String> args = []

  /**
   * Maximum heap size in megabytes.
   */
  int maxHeapSizeMB = project.hasProperty('haleMaxHeapSize') ? (project.getProperty('haleMaxHeapSize') as int) : 2048

  /**
   * States if the hale CLI tool (or library) is required, i.e
   * halestudio cannot be used.
   */
  boolean requiresHaleCli = false

  /**
   * Map of project variables.
   */
  Map<String, String> projectVariables = [:]

  @TaskAction
  void runCommand() {
    // build command line
    def cmd

    boolean usingHaleCli = false
    boolean useCommandLine = true

    // executable
    if (project.hasProperty('haleCliExecutable')) {
      println 'Using hale CLI executable at ' + project.getProperty('haleCliExecutable')
      cmd = [project.getProperty('haleCliExecutable')]
      cmd.addAll(args)
      usingHaleCli = true
    }
    else {
      // using libraries on classpath
      println 'Using libraries on classpath...'
      cmd = args
      usingHaleCli = false
      useCommandLine = false
    }

    if (useCommandLine) {
      // execution via external command

      project.exec {
        commandLine = cmd

        // environment
        
        // HALE_OPTS if using hale-cli
        if (usingHaleCli) {
          List<String> haleOpts = []
          
          // max heap size
          haleOpts << "-Xmx${maxHeapSizeMB}m"

          // proxy configuration
          Helpers.addProxyArgs(haleOpts)
          // additional system properties
          Helpers.addSystemProps(project, haleOpts)

          if (haleOpts) {
            environment('HALE_OPTS', haleOpts.join(' '))
          }
        }
      }
    }
    else {
      // execution via libraries in classpath

      project.javaexec {
        classpath project.configurations.hale
        main = "to.wetransform.halecli.CLI"
        args = cmd
        def vmargs = ['-Dcache.level1.enabled=false', '-Dcache.level1.size=0',
          '-Dcache.level2.enabled=false', '-Dcache.level2.size=0']

        // proxy configuration
        Helpers.addProxyArgs(vmargs)
        // additional system properties
        Helpers.addSystemProps(project, vmargs)

        // max heap size
        maxHeapSize = "${maxHeapSizeMB}m"
        
        jvmArgs = vmargs
      }
    }

  }

}

class Helpers {
  /**
   * List of proxy related system properties.
   */
  static final PROXY_PROPS = [
    'http.proxyHost',
    'http.proxyPort',
    'http.proxyUser',
    'http.proxyPassword',
    'http.nonProxyHosts',
    'https.proxyHost',
    'https.proxyPort',
    'https.proxyUser',
    'https.proxyPassword',
    'https.nonProxyHosts'
  ].asImmutable()

  /**
   * Helper to add HTTP-Proxy system property arguments to an argument list.
   * 
   * @param argList The argument list to add the HTTP-Proxy configuration
   *   arguments to
   */
  static void addProxyArgs(List<String> argList) {
    PROXY_PROPS.each { name ->
      String prop = System.getProperty(name)
      if (prop != null) {
        argList << "-D${name}=${prop}"
      }
    }
  }

  /**
   * Add additionally defined system properties to the arguments.
   * 
   * @param argList The argument list to add the system properties to
   */
  static void addSystemProps(Project project, List<String> argList) {
    def propsFile = project.file('gradle.properties')
    if (!propsFile.exists()) {
      return
    }
    try {
      def props = new Properties()
      propsFile.withInputStream {
        props.load(it)
      }

      props.stringPropertyNames().each { name ->
        if (name.startsWith('systemProp.')) {
          def value = props.getProperty(name)
          if (value) {
            def strippedName = name[11..-1]
            if (!PROXY_PROPS.contains(strippedName)) {
              // don't handle proxy properties two times

              println "Adding system property ${strippedName} to command"
              argList << "-D${strippedName}=${value}"
            }
          }
        }
      }
    } catch (e) {
      println 'ERROR loading gradle.properties to extract system properties'
      e.printStackTrace()
    }
  }
}

class TeeOutputStream extends OutputStream {

  private final OutputStream out
  private final OutputStream tee

  TeeOutputStream(OutputStream out, OutputStream tee) {
    if (out == null)
      throw new NullPointerException()
    else if (tee == null)
      throw new NullPointerException()

    this.out = out
    this.tee = tee
  }

  @Override
  void write(int b) throws IOException {
    out.write(b);
    tee.write(b);
  }

  @Override
  void write(byte[] b) throws IOException {
    out.write(b);
    tee.write(b);
  }

  @Override
  void write(byte[] b, int off, int len) throws IOException {
    out.write(b, off, len);
    tee.write(b, off, len);
  }

  @Override
  void flush() throws IOException {
    out.flush();
    tee.flush();
  }

  @Override
  void close() throws IOException {
    out.close();
    tee.close();
  }
}

/*
 * Gradle wrapper
 */
task wrapper(type: Wrapper) {
  gradleVersion = '3.2'
}
